(function (root, factory) { if (typeof define === "function" && define.amd) { define(["cldr", "../globalize", "./number", "cldr/event", "cldr/supplemental"], factory) } else if (typeof exports === "object") { module.exports = factory(require("cldrjs"), require("globalize")) } else { factory(root.Cldr, root.Globalize) } })(this, function (Cldr, Globalize) { var createError = Globalize._createError, createErrorUnsupportedFeature = Globalize._createErrorUnsupportedFeature, formatMessage = Globalize._formatMessage, numberSymbol = Globalize._numberSymbol, regexpEscape = Globalize._regexpEscape, runtimeBind = Globalize._runtimeBind, stringPad = Globalize._stringPad, validateCldr = Globalize._validateCldr, validateDefaultLocale = Globalize._validateDefaultLocale, validateParameterPresence = Globalize._validateParameterPresence, validateParameterType = Globalize._validateParameterType, validateParameterTypePlainObject = Globalize._validateParameterTypePlainObject, validateParameterTypeString = Globalize._validateParameterTypeString; var validateParameterTypeDate = function (value, name) { validateParameterType(value, name, value === undefined || value instanceof Date, "Date") }; var createErrorInvalidParameterValue = function (name, value) { return createError("E_INVALID_PAR_VALUE", "Invalid `{name}` value ({value}).", { name: name, value: value }) }; var dateExpandPattern = function (options, cldr) { var dateSkeleton, result, skeleton, timeSkeleton, type; function combineDateTime(type, datePattern, timePattern) { return formatMessage(cldr.main(["dates/calendars/gregorian/dateTimeFormats", type]), [timePattern, datePattern]) } switch (true) { case "skeleton" in options: skeleton = options.skeleton; result = cldr.main(["dates/calendars/gregorian/dateTimeFormats/availableFormats", skeleton]); if (!result) { timeSkeleton = skeleton.split(/[^hHKkmsSAzZOvVXx]/).slice(-1)[0]; dateSkeleton = skeleton.split(/[^GyYuUrQqMLlwWdDFgEec]/)[0]; if (/(MMMM|LLLL).*[Ec]/.test(dateSkeleton)) { type = "full" } else if (/MMMM/g.test(dateSkeleton)) { type = "long" } else if (/MMM/g.test(dateSkeleton) || /LLL/g.test(dateSkeleton)) { type = "medium" } else { type = "short" } result = combineDateTime(type, cldr.main(["dates/calendars/gregorian/dateTimeFormats/availableFormats", dateSkeleton]), cldr.main(["dates/calendars/gregorian/dateTimeFormats/availableFormats", timeSkeleton])) } break; case "date" in options: case "time" in options: result = cldr.main(["dates/calendars/gregorian", "date" in options ? "dateFormats" : "timeFormats", options.date || options.time]); break; case "datetime" in options: result = combineDateTime(options.datetime, cldr.main(["dates/calendars/gregorian/dateFormats", options.datetime]), cldr.main(["dates/calendars/gregorian/timeFormats", options.datetime])); break; case "raw" in options: result = options.raw; break; default: throw createErrorInvalidParameterValue({ name: "options", value: options }) } return result }; var dateDayOfWeek = function (date, firstDay) { return (date.getDay() - firstDay + 7) % 7 }; var dateDistanceInDays = function (from, to) { var inDays = 864e5; return (to.getTime() - from.getTime()) / inDays }; var dateStartOf = function (date, unit) { date = new Date(date.getTime()); switch (unit) { case "year": date.setMonth(0); case "month": date.setDate(1); case "day": date.setHours(0); case "hour": date.setMinutes(0); case "minute": date.setSeconds(0); case "second": date.setMilliseconds(0) } return date }; var dateDayOfYear = function (date) { return Math.floor(dateDistanceInDays(dateStartOf(date, "year"), date)) }; var dateMillisecondsInDay = function (date) { return date - dateStartOf(date, "day") }; var datePatternRe = /([a-z])\1*|'([^']|'')+'|''|./gi; var dateTimezoneHourFormat = function (date, format, timeSeparator, formatNumber) { var absOffset, offset = date.getTimezoneOffset(); absOffset = Math.abs(offset); formatNumber = formatNumber || { 1: function (value) { return stringPad(value, 1) }, 2: function (value) { return stringPad(value, 2) } }; return format.split(";")[offset > 0 ? 1 : 0].replace(":", timeSeparator).replace(/HH?/, function (match) { return formatNumber[match.length](Math.floor(absOffset / 60)) }).replace(/mm/, function () { return formatNumber[2](absOffset % 60) }) }; var dateWeekDays = ["sun", "mon", "tue", "wed", "thu", "fri", "sat"]; var dateFormat = function (date, numberFormatters, properties) { var timeSeparator = properties.timeSeparator; return properties.pattern.replace(datePatternRe, function (current) { var ret, chr = current.charAt(0), length = current.length; if (chr === "j") { chr = properties.preferredTime } if (chr === "Z") { if (length < 4) { chr = "x"; length = 4 } else if (length < 5) { chr = "O"; length = 4 } else { chr = "X"; length = 5 } } switch (chr) { case "G": ret = properties.eras[date.getFullYear() < 0 ? 0 : 1]; break; case "y": ret = date.getFullYear(); if (length === 2) { ret = String(ret); ret = +ret.substr(ret.length - 2) } break; case "Y": ret = new Date(date.getTime()); ret.setDate(ret.getDate() + 7 - dateDayOfWeek(date, properties.firstDay) - properties.firstDay - properties.minDays); ret = ret.getFullYear(); if (length === 2) { ret = String(ret); ret = +ret.substr(ret.length - 2) } break; case "Q": case "q": ret = Math.ceil((date.getMonth() + 1) / 3); if (length > 2) { ret = properties.quarters[chr][length][ret] } break; case "M": case "L": ret = date.getMonth() + 1; if (length > 2) { ret = properties.months[chr][length][ret] } break; case "w": ret = dateDayOfWeek(dateStartOf(date, "year"), properties.firstDay); ret = Math.ceil((dateDayOfYear(date) + ret) / 7) - (7 - ret >= properties.minDays ? 0 : 1); break; case "W": ret = dateDayOfWeek(dateStartOf(date, "month"), properties.firstDay); ret = Math.ceil((date.getDate() + ret) / 7) - (7 - ret >= properties.minDays ? 0 : 1); break; case "d": ret = date.getDate(); break; case "D": ret = dateDayOfYear(date) + 1; break; case "F": ret = Math.floor(date.getDate() / 7) + 1; break; case "e": case "c": if (length <= 2) { ret = dateDayOfWeek(date, properties.firstDay) + 1; break } case "E": ret = dateWeekDays[date.getDay()]; ret = properties.days[chr][length][ret]; break; case "a": ret = properties.dayPeriods[date.getHours() < 12 ? "am" : "pm"]; break; case "h": ret = date.getHours() % 12 || 12; break; case "H": ret = date.getHours(); break; case "K": ret = date.getHours() % 12; break; case "k": ret = date.getHours() || 24; break; case "m": ret = date.getMinutes(); break; case "s": ret = date.getSeconds(); break; case "S": ret = Math.round(date.getMilliseconds() * Math.pow(10, length - 3)); break; case "A": ret = Math.round(dateMillisecondsInDay(date) * Math.pow(10, length - 3)); break; case "z": case "O": if (date.getTimezoneOffset() === 0) { ret = properties.gmtZeroFormat } else { ret = dateTimezoneHourFormat(date, length < 4 ? "+H;-H" : properties.tzLongHourFormat, timeSeparator, numberFormatters); ret = properties.gmtFormat.replace(/\{0\}/, ret) } break; case "X": if (date.getTimezoneOffset() === 0) { ret = "Z"; break } case "x": ret = length === 1 ? "+HH;-HH" : length % 2 ? "+HH:mm;-HH:mm" : "+HHmm;-HHmm"; ret = dateTimezoneHourFormat(date, ret, ":"); break; case ":": ret = timeSeparator; break; case "'": current = current.replace(/''/, "'"); if (length > 2) { current = current.slice(1, -1) } ret = current; break; default: ret = current } if (typeof ret === "number") { ret = numberFormatters[length](ret) } return ret }) }; var dateFormatterFn = function (numberFormatters, properties) { return function dateFormatter(value) { validateParameterPresence(value, "value"); validateParameterTypeDate(value, "value"); return dateFormat(value, numberFormatters, properties) } }; var dateFirstDayOfWeek = function (cldr) { return dateWeekDays.indexOf(cldr.supplemental.weekData.firstDay()) }; var dateFormatProperties = function (pattern, cldr) { var properties = { numberFormatters: {}, pattern: pattern, timeSeparator: numberSymbol("timeSeparator", cldr) }, widths = ["abbreviated", "wide", "narrow"]; function setNumberFormatterPattern(pad) { properties.numberFormatters[pad] = stringPad("", pad) } pattern.replace(datePatternRe, function (current) { var formatNumber, chr = current.charAt(0), length = current.length; if (chr === "j") { properties.preferredTime = chr = cldr.supplemental.timeData.preferred() } if (chr === "Z" && length === 4) { chr = "O"; length = 4 } switch (chr) { case "G": properties.eras = cldr.main(["dates/calendars/gregorian/eras", length <= 3 ? "eraAbbr" : length === 4 ? "eraNames" : "eraNarrow"]); break; case "y": formatNumber = true; break; case "Y": properties.firstDay = dateFirstDayOfWeek(cldr); properties.minDays = cldr.supplemental.weekData.minDays(); formatNumber = true; break; case "u": case "U": throw createErrorUnsupportedFeature({ feature: "year pattern `" + chr + "`" }); case "Q": case "q": if (length > 2) { if (!properties.quarters) { properties.quarters = {} } if (!properties.quarters[chr]) { properties.quarters[chr] = {} } properties.quarters[chr][length] = cldr.main(["dates/calendars/gregorian/quarters", chr === "Q" ? "format" : "stand-alone", widths[length - 3]]) } else { formatNumber = true } break; case "M": case "L": if (length > 2) { if (!properties.months) { properties.months = {} } if (!properties.months[chr]) { properties.months[chr] = {} } properties.months[chr][length] = cldr.main(["dates/calendars/gregorian/months", chr === "M" ? "format" : "stand-alone", widths[length - 3]]) } else { formatNumber = true } break; case "w": case "W": properties.firstDay = dateFirstDayOfWeek(cldr); properties.minDays = cldr.supplemental.weekData.minDays(); formatNumber = true; break; case "d": case "D": case "F": formatNumber = true; break; case "g": throw createErrorUnsupportedFeature({ feature: "Julian day pattern `g`" }); case "e": case "c": if (length <= 2) { properties.firstDay = dateFirstDayOfWeek(cldr); formatNumber = true; break } case "E": if (!properties.days) { properties.days = {} } if (!properties.days[chr]) { properties.days[chr] = {} } if (length === 6) { properties.days[chr][length] = cldr.main(["dates/calendars/gregorian/days", chr === "c" ? "stand-alone" : "format", "short"]) || cldr.main(["dates/calendars/gregorian/days", chr === "c" ? "stand-alone" : "format", "abbreviated"]) } else { properties.days[chr][length] = cldr.main(["dates/calendars/gregorian/days", chr === "c" ? "stand-alone" : "format", widths[length < 3 ? 0 : length - 3]]) } break; case "a": properties.dayPeriods = cldr.main("dates/calendars/gregorian/dayPeriods/format/wide"); break; case "h": case "H": case "K": case "k": case "m": case "s": case "S": case "A": formatNumber = true; break; case "z": case "O": properties.gmtFormat = cldr.main("dates/timeZoneNames/gmtFormat"); properties.gmtZeroFormat = cldr.main("dates/timeZoneNames/gmtZeroFormat"); properties.tzLongHourFormat = cldr.main("dates/timeZoneNames/hourFormat"); case "Z": case "X": case "x": setNumberFormatterPattern(1); setNumberFormatterPattern(2); break; case "v": case "V": throw createErrorUnsupportedFeature({ feature: "timezone pattern `" + chr + "`" }) } if (formatNumber) { setNumberFormatterPattern(length) } }); return properties }; var dateIsLeapYear = function (year) { return new Date(year, 1, 29).getMonth() === 1 }; var dateLastDayOfMonth = function (date) { return new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate() }; var dateSetDate = function (date, day) { var lastDay = new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate(); date.setDate(day < 1 ? 1 : day < lastDay ? day : lastDay) }; var dateSetMonth = function (date, month) { var originalDate = date.getDate(); date.setDate(1); date.setMonth(month); dateSetDate(date, originalDate) }; var outOfRange = function (value, low, high) { return value < low || value > high }; var dateParse = function (value, tokens, properties) { var amPm, day, daysOfYear, month, era, hour, hour12, timezoneOffset, valid, YEAR = 0, MONTH = 1, DAY = 2, HOUR = 3, MINUTE = 4, SECOND = 5, MILLISECONDS = 6, date = new Date, truncateAt = [], units = ["year", "month", "day", "hour", "minute", "second", "milliseconds"]; if (!tokens.length) { return null } valid = tokens.every(function (token) { var century, chr, value, length; if (token.type === "literal") { return true } chr = token.type.charAt(0); length = token.type.length; if (chr === "j") { chr = properties.preferredTimeData } switch (chr) { case "G": truncateAt.push(YEAR); era = +token.value; break; case "y": value = token.value; if (length === 2) { if (outOfRange(value, 0, 99)) { return false } century = Math.floor(date.getFullYear() / 100) * 100; value += century; if (value > date.getFullYear() + 20) { value -= 100 } } date.setFullYear(value); truncateAt.push(YEAR); break; case "Y": throw createErrorUnsupportedFeature({ feature: "year pattern `" + chr + "`" }); case "Q": case "q": break; case "M": case "L": if (length <= 2) { value = token.value } else { value = +token.value } if (outOfRange(value, 1, 12)) { return false } month = value; truncateAt.push(MONTH); break; case "w": case "W": break; case "d": day = token.value; truncateAt.push(DAY); break; case "D": daysOfYear = token.value; truncateAt.push(DAY); break; case "F": break; case "e": case "c": case "E": break; case "a": amPm = token.value; break; case "h": value = token.value; if (outOfRange(value, 1, 12)) { return false } hour = hour12 = true; date.setHours(value === 12 ? 0 : value); truncateAt.push(HOUR); break; case "K": value = token.value; if (outOfRange(value, 0, 11)) { return false } hour = hour12 = true; date.setHours(value); truncateAt.push(HOUR); break; case "k": value = token.value; if (outOfRange(value, 1, 24)) { return false } hour = true; date.setHours(value === 24 ? 0 : value); truncateAt.push(HOUR); break; case "H": value = token.value; if (outOfRange(value, 0, 23)) { return false } hour = true; date.setHours(value); truncateAt.push(HOUR); break; case "m": value = token.value; if (outOfRange(value, 0, 59)) { return false } date.setMinutes(value); truncateAt.push(MINUTE); break; case "s": value = token.value; if (outOfRange(value, 0, 59)) { return false } date.setSeconds(value); truncateAt.push(SECOND); break; case "A": date.setHours(0); date.setMinutes(0); date.setSeconds(0); case "S": value = Math.round(token.value * Math.pow(10, 3 - length)); date.setMilliseconds(value); truncateAt.push(MILLISECONDS); break; case "Z": case "z": case "O": case "X": case "x": timezoneOffset = token.value - date.getTimezoneOffset(); break } return true }); if (!valid) { return null } if (hour && !(!amPm ^ hour12)) { return null } if (era === 0) { date.setFullYear(date.getFullYear() * -1 + 1) } if (month !== undefined) { dateSetMonth(date, month - 1) } if (day !== undefined) { if (outOfRange(day, 1, dateLastDayOfMonth(date))) { return null } date.setDate(day) } else if (daysOfYear !== undefined) { if (outOfRange(daysOfYear, 1, dateIsLeapYear(date.getFullYear()) ? 366 : 365)) { return null } date.setMonth(0); date.setDate(daysOfYear) } if (hour12 && amPm === "pm") { date.setHours(date.getHours() + 12) } if (timezoneOffset) { date.setMinutes(date.getMinutes() + timezoneOffset) } truncateAt = Math.max.apply(null, truncateAt); date = dateStartOf(date, units[truncateAt]); return date }; var regexpN = /[0-9\xB2\xB3\xB9\xBC-\xBE\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u09F4-\u09F9\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0B72-\u0B77\u0BE6-\u0BF2\u0C66-\u0C6F\u0C78-\u0C7E\u0CE6-\u0CEF\u0D66-\u0D75\u0DE6-\u0DEF\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F33\u1040-\u1049\u1090-\u1099\u1369-\u137C\u16EE-\u16F0\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1946-\u194F\u19D0-\u19DA\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\u2070\u2074-\u2079\u2080-\u2089\u2150-\u2182\u2185-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2CFD\u3007\u3021-\u3029\u3038-\u303A\u3192-\u3195\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\uA620-\uA629\uA6E6-\uA6EF\uA830-\uA835\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uA9F0-\uA9F9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19]|\uD800[\uDD07-\uDD33\uDD40-\uDD78\uDD8A\uDD8B\uDEE1-\uDEFB\uDF20-\uDF23\uDF41\uDF4A\uDFD1-\uDFD5]|\uD801[\uDCA0-\uDCA9]|\uD802[\uDC58-\uDC5F\uDC79-\uDC7F\uDCA7-\uDCAF\uDD16-\uDD1B\uDE40-\uDE47\uDE7D\uDE7E\uDE9D-\uDE9F\uDEEB-\uDEEF\uDF58-\uDF5F\uDF78-\uDF7F\uDFA9-\uDFAF]|\uD803[\uDE60-\uDE7E]|\uD804[\uDC52-\uDC6F\uDCF0-\uDCF9\uDD36-\uDD3F\uDDD0-\uDDD9\uDDE1-\uDDF4\uDEF0-\uDEF9]|\uD805[\uDCD0-\uDCD9\uDE50-\uDE59\uDEC0-\uDEC9]|\uD806[\uDCE0-\uDCF2]|\uD809[\uDC00-\uDC6E]|\uD81A[\uDE60-\uDE69\uDF50-\uDF59\uDF5B-\uDF61]|\uD834[\uDF60-\uDF71]|\uD835[\uDFCE-\uDFFF]|\uD83A[\uDCC7-\uDCCF]|\uD83C[\uDD00-\uDD0C]/; var dateTokenizer = function (value, numberParser, properties) { var valid, timeSeparator = properties.timeSeparator, tokens = [], widths = ["abbreviated", "wide", "narrow"]; valid = properties.pattern.match(datePatternRe).every(function (current) { var chr, length, numeric, tokenRe, token = {}; function hourFormatParse(tokenRe, numberParser) { var aux = value.match(tokenRe); numberParser = numberParser || function (value) { return +value }; if (!aux) { return false } if (aux.length < 8) { token.value = (aux[1] ? -numberParser(aux[1]) : numberParser(aux[4])) * 60 } else { token.value = (aux[1] ? -numberParser(aux[1]) : numberParser(aux[7])) * 60 + (aux[1] ? -numberParser(aux[4]) : numberParser(aux[10])) } return true } function hourFormatRe(hourFormat, gmtFormat, timeSeparator) { var re; if (!gmtFormat) { gmtFormat = "{0}" } re = hourFormat.replace("+", "\\+").replace(/HH|mm/g, "((" + regexpN.source + ")(" + regexpN.source + "))").replace(/H|m/g, "((" + regexpN.source + ")(" + regexpN.source + ")?)"); if (timeSeparator) { re = re.replace(/:/g, timeSeparator) } re = re.split(";").map(function (part) { return gmtFormat.replace("{0}", part) }).join("|"); return new RegExp(re) } function oneDigitIfLengthOne() { if (length === 1) { numeric = true; return tokenRe = regexpN } } function oneOrTwoDigitsIfLengthOne() { if (length === 1) { numeric = true; return tokenRe = new RegExp("(" + regexpN.source + ")(" + regexpN.source + ")?") } } function twoDigitsIfLengthTwo() { if (length === 2) { numeric = true; return tokenRe = new RegExp("(" + regexpN.source + ")(" + regexpN.source + ")") } } function lookup(path) { var i, re, data = properties[path.join("/")]; for (i in data) { re = new RegExp("^" + data[i]); if (re.test(value)) { token.value = i; return tokenRe = new RegExp(data[i]) } } return null } token.type = current; chr = current.charAt(0), length = current.length; if (chr === "Z") { if (length < 4) { chr = "x"; length = 4 } else if (length < 5) { chr = "O"; length = 4 } else { chr = "X"; length = 5 } } switch (chr) { case "G": lookup(["gregorian/eras", length <= 3 ? "eraAbbr" : length === 4 ? "eraNames" : "eraNarrow"]); break; case "y": case "Y": numeric = true; if (length === 1) { tokenRe = new RegExp("(" + regexpN.source + ")+") } else if (length === 2) { tokenRe = new RegExp("(" + regexpN.source + ")(" + regexpN.source + ")") } else { tokenRe = new RegExp("(" + regexpN.source + "){" + length + ",}") } break; case "Q": case "q": oneDigitIfLengthOne() || twoDigitsIfLengthTwo() || lookup(["gregorian/quarters", chr === "Q" ? "format" : "stand-alone", widths[length - 3]]); break; case "M": case "L": oneOrTwoDigitsIfLengthOne() || twoDigitsIfLengthTwo() || lookup(["gregorian/months", chr === "M" ? "format" : "stand-alone", widths[length - 3]]); break; case "D": if (length <= 3) { numeric = true; tokenRe = new RegExp("(" + regexpN.source + "){" + length + ",3}") } break; case "W": case "F": oneDigitIfLengthOne(); break; case "e": case "c": if (length <= 2) { oneDigitIfLengthOne() || twoDigitsIfLengthTwo(); break } case "E": if (length === 6) { lookup(["gregorian/days", [chr === "c" ? "stand-alone" : "format"], "short"]) || lookup(["gregorian/days", [chr === "c" ? "stand-alone" : "format"], "abbreviated"]) } else { lookup(["gregorian/days", [chr === "c" ? "stand-alone" : "format"], widths[length < 3 ? 0 : length - 3]]) } break; case "a": lookup(["gregorian/dayPeriods/format/wide"]); break; case "w": case "d": case "h": case "H": case "K": case "k": case "j": case "m": case "s": oneOrTwoDigitsIfLengthOne() || twoDigitsIfLengthTwo(); break; case "S": numeric = true; tokenRe = new RegExp("(" + regexpN.source + "){" + length + "}"); break; case "A": numeric = true; tokenRe = new RegExp("(" + regexpN.source + "){" + (length + 5) + "}"); break; case "z": case "O": if (value === properties["timeZoneNames/gmtZeroFormat"]) { token.value = 0; tokenRe = new RegExp(properties["timeZoneNames/gmtZeroFormat"]) } else { tokenRe = hourFormatRe(length < 4 ? "+H;-H" : properties["timeZoneNames/hourFormat"], properties["timeZoneNames/gmtFormat"], timeSeparator); if (!hourFormatParse(tokenRe, numberParser)) { return null } } break; case "X": if (value === "Z") { token.value = 0; tokenRe = /Z/; break } case "x": tokenRe = hourFormatRe(length === 1 ? "+HH;-HH" : length % 2 ? "+HH:mm;-HH:mm" : "+HHmm;-HHmm"); if (!hourFormatParse(tokenRe)) { return null } break; case "'": token.type = "literal"; current = current.replace(/''/, "'"); if (length > 2) { current = current.slice(1, -1) } tokenRe = new RegExp(regexpEscape(current)); break; default: token.type = "literal"; tokenRe = /./ } if (!tokenRe) { return false } value = value.replace(new RegExp("^" + tokenRe.source), function (lexeme) { token.lexeme = lexeme; if (numeric) { token.value = numberParser(lexeme) } return "" }); if (!token.lexeme) { return false } tokens.push(token); return true }); if (value !== "") { valid = false } return valid ? tokens : [] }; var dateParserFn = function (numberParser, parseProperties, tokenizerProperties) { return function dateParser(value) { var tokens; validateParameterPresence(value, "value"); validateParameterTypeString(value, "value"); tokens = dateTokenizer(value, numberParser, tokenizerProperties); return dateParse(value, tokens, parseProperties) || null } }; var dateParseProperties = function (cldr) { return { preferredTimeData: cldr.supplemental.timeData.preferred() } }; var dateTokenizerProperties = function (pattern, cldr) { var properties = { pattern: pattern, timeSeparator: numberSymbol("timeSeparator", cldr) }, widths = ["abbreviated", "wide", "narrow"]; function populateProperties(path, value) { properties[path.replace(/^.*\/dates\//, "").replace(/calendars\//, "")] = value } cldr.on("get", populateProperties); pattern.match(datePatternRe).forEach(function (current) { var chr, length; chr = current.charAt(0), length = current.length; if (chr === "Z" && length < 5) { chr = "O"; length = 4 } switch (chr) { case "G": cldr.main(["dates/calendars/gregorian/eras", length <= 3 ? "eraAbbr" : length === 4 ? "eraNames" : "eraNarrow"]); break; case "u": case "U": throw createErrorUnsupportedFeature({ feature: "year pattern `" + chr + "`" }); case "Q": case "q": if (length > 2) { cldr.main(["dates/calendars/gregorian/quarters", chr === "Q" ? "format" : "stand-alone", widths[length - 3]]) } break; case "M": case "L": if (length > 2) { cldr.main(["dates/calendars/gregorian/months", chr === "M" ? "format" : "stand-alone", widths[length - 3]]) } break; case "g": throw createErrorUnsupportedFeature({ feature: "Julian day pattern `g`" }); case "e": case "c": if (length <= 2) { break } case "E": if (length === 6) { cldr.main(["dates/calendars/gregorian/days", [chr === "c" ? "stand-alone" : "format"], "short"]) || cldr.main(["dates/calendars/gregorian/days", [chr === "c" ? "stand-alone" : "format"], "abbreviated"]) } else { cldr.main(["dates/calendars/gregorian/days", [chr === "c" ? "stand-alone" : "format"], widths[length < 3 ? 0 : length - 3]]) } break; case "a": cldr.main(["dates/calendars/gregorian/dayPeriods/format/wide"]); break; case "z": case "O": cldr.main("dates/timeZoneNames/gmtFormat"); cldr.main("dates/timeZoneNames/gmtZeroFormat"); cldr.main("dates/timeZoneNames/hourFormat"); break; case "v": case "V": throw createErrorUnsupportedFeature({ feature: "timezone pattern `" + chr + "`" }) } }); cldr.off("get", populateProperties); return properties }; function validateRequiredCldr(path, value) { validateCldr(path, value, { skip: [/dates\/calendars\/gregorian\/dateTimeFormats\/availableFormats/, /dates\/calendars\/gregorian\/days\/.*\/short/, /supplemental\/timeData\/(?!001)/, /supplemental\/weekData\/(?!001)/] }) } Globalize.dateFormatter = Globalize.prototype.dateFormatter = function (options) { var args, cldr, numberFormatters, pad, pattern, properties, returnFn; validateParameterTypePlainObject(options, "options"); cldr = this.cldr; options = options || { skeleton: "yMd" }; args = [options]; validateDefaultLocale(cldr); cldr.on("get", validateRequiredCldr); pattern = dateExpandPattern(options, cldr); properties = dateFormatProperties(pattern, cldr); cldr.off("get", validateRequiredCldr); numberFormatters = properties.numberFormatters; delete properties.numberFormatters; for (pad in numberFormatters) { numberFormatters[pad] = this.numberFormatter({ raw: numberFormatters[pad] }) } returnFn = dateFormatterFn(numberFormatters, properties); runtimeBind(args, cldr, returnFn, [numberFormatters, properties]); return returnFn }; Globalize.dateParser = Globalize.prototype.dateParser = function (options) { var args, cldr, numberParser, parseProperties, pattern, tokenizerProperties, returnFn; validateParameterTypePlainObject(options, "options"); cldr = this.cldr; options = options || { skeleton: "yMd" }; args = [options]; validateDefaultLocale(cldr); cldr.on("get", validateRequiredCldr); pattern = dateExpandPattern(options, cldr); tokenizerProperties = dateTokenizerProperties(pattern, cldr); parseProperties = dateParseProperties(cldr); cldr.off("get", validateRequiredCldr); numberParser = this.numberParser({ raw: "0" }); returnFn = dateParserFn(numberParser, parseProperties, tokenizerProperties); runtimeBind(args, cldr, returnFn, [numberParser, parseProperties, tokenizerProperties]); return returnFn }; Globalize.formatDate = Globalize.prototype.formatDate = function (value, options) { validateParameterPresence(value, "value"); validateParameterTypeDate(value, "value"); return this.dateFormatter(options)(value) }; Globalize.parseDate = Globalize.prototype.parseDate = function (value, options) { validateParameterPresence(value, "value"); validateParameterTypeString(value, "value"); return this.dateParser(options)(value) }; return Globalize });