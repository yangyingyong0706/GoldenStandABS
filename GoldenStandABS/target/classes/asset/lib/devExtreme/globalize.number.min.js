(function (root, factory) { if (typeof define === "function" && define.amd) { define(["cldr", "../globalize", "cldr/event", "cldr/supplemental"], factory) } else if (typeof exports === "object") { module.exports = factory(require("cldrjs"), require("globalize")) } else { factory(root.Cldr, root.Globalize) } })(this, function (Cldr, Globalize) { var createError = Globalize._createError, objectExtend = Globalize._objectExtend, regexpEscape = Globalize._regexpEscape, runtimeBind = Globalize._runtimeBind, stringPad = Globalize._stringPad, validateCldr = Globalize._validateCldr, validateDefaultLocale = Globalize._validateDefaultLocale, validateParameterPresence = Globalize._validateParameterPresence, validateParameterRange = Globalize._validateParameterRange, validateParameterType = Globalize._validateParameterType, validateParameterTypePlainObject = Globalize._validateParameterTypePlainObject; var createErrorUnsupportedFeature = function (feature) { return createError("E_UNSUPPORTED", "Unsupported {feature}.", { feature: feature }) }; var validateParameterTypeNumber = function (value, name) { validateParameterType(value, name, value === undefined || typeof value === "number", "Number") }; var validateParameterTypeString = function (value, name) { validateParameterType(value, name, value === undefined || typeof value === "string", "a string") }; var numberFormatGroupingSeparator = function (number, primaryGroupingSize, secondaryGroupingSize) { var index, currentGroupingSize = primaryGroupingSize, ret = "", sep = ",", switchToSecondary = secondaryGroupingSize ? true : false; number = String(number).split("."); index = number[0].length; while (index > currentGroupingSize) { ret = number[0].slice(index - currentGroupingSize, index) + (ret.length ? sep : "") + ret; index -= currentGroupingSize; if (switchToSecondary) { currentGroupingSize = secondaryGroupingSize; switchToSecondary = false } } number[0] = number[0].slice(0, index) + (ret.length ? sep : "") + ret; return number.join(".") }; var numberFormatIntegerFractionDigits = function (number, minimumIntegerDigits, minimumFractionDigits, maximumFractionDigits, round, roundIncrement) { if (maximumFractionDigits) { if (roundIncrement) { number = round(number, roundIncrement) } else { number = round(number, { exponent: -maximumFractionDigits }) } if (minimumFractionDigits) { number = String(number).split("."); number[1] = stringPad(number[1] || "", minimumFractionDigits, true); number = number.join(".") } } else { number = round(number) } number = String(number); if (minimumIntegerDigits) { number = number.split("."); number[0] = stringPad(number[0], minimumIntegerDigits); number = number.join(".") } return number }; var numberToPrecision = function (number, precision, round) { var roundOrder; number = number.toPrecision(precision + 2); roundOrder = Math.ceil(Math.log(Math.abs(number)) / Math.log(10)); roundOrder -= precision; return round(number, { exponent: roundOrder }) }; var numberFormatSignificantDigits = function (number, minimumSignificantDigits, maximumSignificantDigits, round) { var atMinimum, atMaximum; if (minimumSignificantDigits > maximumSignificantDigits) { maximumSignificantDigits = minimumSignificantDigits } atMinimum = numberToPrecision(number, minimumSignificantDigits, round); atMaximum = numberToPrecision(number, maximumSignificantDigits, round); number = +atMinimum === +atMaximum ? atMinimum : atMaximum; number = (+number).toString(10); if (/e/.test(number)) { throw createErrorUnsupportedFeature({ feature: "integers out of (1e21, 1e-7)" }) } if (minimumSignificantDigits - number.replace(/^0+|\./g, "").length > 0) { number = number.split("."); number[1] = stringPad(number[1] || "", minimumSignificantDigits - number[0].replace(/^0+/, "").length, true); number = number.join(".") } return number }; var numberFormat = function (number, properties) { var infinitySymbol, maximumFractionDigits, maximumSignificantDigits, minimumFractionDigits, minimumIntegerDigits, minimumSignificantDigits, nanSymbol, nuDigitsMap, padding, prefix, primaryGroupingSize, pattern, ret, round, roundIncrement, secondaryGroupingSize, suffix, symbolMap; padding = properties[1]; minimumIntegerDigits = properties[2]; minimumFractionDigits = properties[3]; maximumFractionDigits = properties[4]; minimumSignificantDigits = properties[5]; maximumSignificantDigits = properties[6]; roundIncrement = properties[7]; primaryGroupingSize = properties[8]; secondaryGroupingSize = properties[9]; round = properties[15]; infinitySymbol = properties[16]; nanSymbol = properties[17]; symbolMap = properties[18]; nuDigitsMap = properties[19]; if (isNaN(number)) { return nanSymbol } if (number < 0) { pattern = properties[12]; prefix = properties[13]; suffix = properties[14] } else { pattern = properties[11]; prefix = properties[0]; suffix = properties[10] } if (!isFinite(number)) { return prefix + infinitySymbol + suffix } ret = prefix; if (pattern.indexOf("%") !== -1) { number *= 100 } else if (pattern.indexOf("‰") !== -1) { number *= 1e3 } if (!isNaN(minimumSignificantDigits * maximumSignificantDigits)) { number = numberFormatSignificantDigits(number, minimumSignificantDigits, maximumSignificantDigits, round) } else { number = numberFormatIntegerFractionDigits(number, minimumIntegerDigits, minimumFractionDigits, maximumFractionDigits, round, roundIncrement) } number = number.replace(/^-/, ""); if (primaryGroupingSize) { number = numberFormatGroupingSeparator(number, primaryGroupingSize, secondaryGroupingSize) } ret += number; ret += suffix; return ret.replace(/('([^']|'')+'|'')|./g, function (character, literal) { if (literal) { literal = literal.replace(/''/, "'"); if (literal.length > 2) { literal = literal.slice(1, -1) } return literal } character = character.replace(/[.,\-+E%\u2030]/, function (symbol) { return symbolMap[symbol] }); if (nuDigitsMap) { character = character.replace(/[0-9]/, function (digit) { return nuDigitsMap[+digit] }) } return character }) }; var numberFormatterFn = function (properties) { return function numberFormatter(value) { validateParameterPresence(value, "value"); validateParameterTypeNumber(value, "value"); return numberFormat(value, properties) } }; var numberNumberingSystem = function (cldr) { var nu = cldr.attributes["u-nu"]; if (nu) { if (nu === "traditio") { nu = "traditional" } if (["native", "traditional", "finance"].indexOf(nu) !== -1) { return cldr.main(["numbers/otherNumberingSystems", nu]) } return nu } return cldr.main("numbers/defaultNumberingSystem") }; var numberNumberingSystemDigitsMap = function (cldr) { var aux, nu = numberNumberingSystem(cldr); if (nu === "latn") { return } aux = cldr.supplemental(["numberingSystems", nu]); if (aux._type !== "numeric") { throw createErrorUnsupportedFeature("`" + aux._type + "` numbering system") } return aux._digits }; var numberPatternRe = /^(('[^']+'|''|[^*#@0,.E])*)(\*.)?((([#,]*[0,]*0+)(\.0*[0-9]*#*)?)|([#,]*@+#*))(E\+?0+)?(('[^']+'|''|[^*#@0,.E])*)$/; var numberPatternProperties = function (pattern) { var aux1, aux2, fractionPattern, integerFractionOrSignificantPattern, integerPattern, maximumFractionDigits, maximumSignificantDigits, minimumFractionDigits, minimumIntegerDigits, minimumSignificantDigits, padding, prefix, primaryGroupingSize, roundIncrement, scientificNotation, secondaryGroupingSize, significantPattern, suffix; pattern = pattern.match(numberPatternRe); if (!pattern) { throw new Error("Invalid pattern: " + pattern) } prefix = pattern[1]; padding = pattern[3]; integerFractionOrSignificantPattern = pattern[4]; significantPattern = pattern[8]; scientificNotation = pattern[9]; suffix = pattern[10]; if (significantPattern) { significantPattern.replace(/(@+)(#*)/, function (match, minimumSignificantDigitsMatch, maximumSignificantDigitsMatch) { minimumSignificantDigits = minimumSignificantDigitsMatch.length; maximumSignificantDigits = minimumSignificantDigits + maximumSignificantDigitsMatch.length }) } else { fractionPattern = pattern[7]; integerPattern = pattern[6]; if (fractionPattern) { fractionPattern.replace(/[0-9]+/, function (match) { minimumFractionDigits = match }); if (minimumFractionDigits) { roundIncrement = +("0." + minimumFractionDigits); minimumFractionDigits = minimumFractionDigits.length } else { minimumFractionDigits = 0 } maximumFractionDigits = fractionPattern.length - 1 } integerPattern.replace(/0+$/, function (match) { minimumIntegerDigits = match.length }) } if (scientificNotation) { throw createErrorUnsupportedFeature({ feature: "scientific notation (not implemented)" }) } if (padding) { throw createErrorUnsupportedFeature({ feature: "padding (not implemented)" }) } if ((aux1 = integerFractionOrSignificantPattern.lastIndexOf(",")) !== -1) { aux2 = integerFractionOrSignificantPattern.split(".")[0]; primaryGroupingSize = aux2.length - aux1 - 1; if ((aux2 = integerFractionOrSignificantPattern.lastIndexOf(",", aux1 - 1)) !== -1) { secondaryGroupingSize = aux1 - 1 - aux2 } } return [prefix, padding, minimumIntegerDigits, minimumFractionDigits, maximumFractionDigits, minimumSignificantDigits, maximumSignificantDigits, roundIncrement, primaryGroupingSize, secondaryGroupingSize, suffix] }; var numberSymbol = function (name, cldr) { return cldr.main(["numbers/symbols-numberSystem-" + numberNumberingSystem(cldr), name]) }; var numberSymbolName = { ".": "decimal", ",": "group", "%": "percentSign", "+": "plusSign", "-": "minusSign", E: "exponential", "‰": "perMille" }; var numberSymbolMap = function (cldr) { var symbol, symbolMap = {}; for (symbol in numberSymbolName) { symbolMap[symbol] = numberSymbol(numberSymbolName[symbol], cldr) } return symbolMap }; var numberTruncate = function (value) { if (isNaN(value)) { return NaN } return Math[value < 0 ? "ceil" : "floor"](value) }; var numberRound = function (method) { method = method || "round"; method = method === "truncate" ? numberTruncate : Math[method]; return function (value, incrementOrExp) { var exp, increment; value = +value; if (isNaN(value)) { return NaN } if (typeof incrementOrExp === "object" && incrementOrExp.exponent) { exp = +incrementOrExp.exponent; increment = 1; if (exp === 0) { return method(value) } if (!(typeof exp === "number" && exp % 1 === 0)) { return NaN } } else { increment = +incrementOrExp || 1; if (increment === 1) { return method(value) } if (isNaN(increment)) { return NaN } increment = increment.toExponential().split("e"); exp = +increment[1]; increment = +increment[0] } value = value.toString().split("e"); value[0] = +value[0] / increment; value[1] = value[1] ? +value[1] - exp : -exp; value = method(+(value[0] + "e" + value[1])); value = value.toString().split("e"); value[0] = +value[0] * increment; value[1] = value[1] ? +value[1] + exp : exp; return +(value[0] + "e" + value[1]) } }; var numberFormatProperties = function (pattern, cldr, options) { var negativePattern, negativePrefix, negativeProperties, negativeSuffix, positivePattern, roundFn, properties; function getOptions(attribute, propertyIndex) { if (attribute in options) { properties[propertyIndex] = options[attribute] } } options = options || {}; pattern = pattern.split(";"); positivePattern = pattern[0]; negativePattern = pattern[1] || "-" + positivePattern; negativeProperties = numberPatternProperties(negativePattern); negativePrefix = negativeProperties[0]; negativeSuffix = negativeProperties[10]; roundFn = numberRound(options.round); roundFn.generatorString = function () { return "numberRound(" + (options.round ? '"' + options.round + '"' : "") + ")" }; properties = numberPatternProperties(positivePattern).concat([positivePattern, negativePrefix + positivePattern + negativeSuffix, negativePrefix, negativeSuffix, roundFn, numberSymbol("infinity", cldr), numberSymbol("nan", cldr), numberSymbolMap(cldr), numberNumberingSystemDigitsMap(cldr)]); getOptions("minimumIntegerDigits", 2); getOptions("minimumFractionDigits", 3); getOptions("maximumFractionDigits", 4); getOptions("minimumSignificantDigits", 5); getOptions("maximumSignificantDigits", 6); if (options.useGrouping === false) { properties[8] = null } if ("minimumFractionDigits" in options && !("maximumFractionDigits" in options)) { properties[4] = Math.max(properties[3], properties[4]) } else if (!("minimumFractionDigits" in options) && "maximumFractionDigits" in options) { properties[3] = Math.min(properties[3], properties[4]) } return properties }; var numberNumberRe = /^([^0-9]*)(([0-9,]*[0-9]+)(\.[0-9]+)?)(E[+-]?[0-9]+)?([^0-9]*)$/; var numberParse = function (value, properties) { var aux, infinitySymbol, invertedNuDigitsMap, invertedSymbolMap, localizedDigitRe, localizedSymbolsRe, negativePrefix, negativeSuffix, number, prefix, suffix; infinitySymbol = properties[0]; invertedSymbolMap = properties[1]; negativePrefix = properties[2]; negativeSuffix = properties[3]; invertedNuDigitsMap = properties[4]; if (aux = value.match(infinitySymbol)) { number = Infinity; prefix = value.slice(0, aux.length); suffix = value.slice(aux.length + 1) } else { localizedSymbolsRe = new RegExp(Object.keys(invertedSymbolMap).map(function (localizedSymbol) { return regexpEscape(localizedSymbol) }).join("|"), "g"); value = value.replace(localizedSymbolsRe, function (localizedSymbol) { return invertedSymbolMap[localizedSymbol] }); if (invertedNuDigitsMap) { localizedDigitRe = new RegExp(Object.keys(invertedNuDigitsMap).map(function (localizedDigit) { return regexpEscape(localizedDigit) }).join("|"), "g"); value = value.replace(localizedDigitRe, function (localizedDigit) { return invertedNuDigitsMap[localizedDigit] }) } if (value.charAt(0) === ".") { value = "0" + value } value = value.match(numberNumberRe); if (!value) { return NaN } prefix = value[1]; suffix = value[6]; number = value[2].replace(/,/g, ""); if (value[5]) { number += value[5] } number = +number; if (isNaN(number)) { return NaN } if (value[0].indexOf("%") !== -1) { number /= 100; suffix = suffix.replace("%", "") } else if (value[0].indexOf("‰") !== -1) { number /= 1e3; suffix = suffix.replace("‰", "") } } if (prefix === negativePrefix && suffix === negativeSuffix) { number *= -1 } return number }; var numberParserFn = function (properties) { return function numberParser(value) { validateParameterPresence(value, "value"); validateParameterTypeString(value, "value"); return numberParse(value, properties) } }; var numberSymbolInvertedMap = function (cldr) { var symbol, symbolMap = {}; for (symbol in numberSymbolName) { symbolMap[numberSymbol(numberSymbolName[symbol], cldr)] = symbol } return symbolMap }; var numberParseProperties = function (pattern, cldr) { var invertedNuDigitsMap, invertedNuDigitsMapSanityCheck, negativePattern, negativeProperties, nuDigitsMap = numberNumberingSystemDigitsMap(cldr); pattern = pattern.split(";"); negativePattern = pattern[1] || "-" + pattern[0]; negativeProperties = numberPatternProperties(negativePattern); if (nuDigitsMap) { invertedNuDigitsMap = nuDigitsMap.split("").reduce(function (object, localizedDigit, i) { object[localizedDigit] = String(i); return object }, {}); invertedNuDigitsMapSanityCheck = "0123456789".split("").reduce(function (object, digit) { object[digit] = "invalid"; return object }, {}); invertedNuDigitsMap = objectExtend(invertedNuDigitsMapSanityCheck, invertedNuDigitsMap) } return [numberSymbol("infinity", cldr), objectExtend({}, numberSymbolName, numberSymbolInvertedMap(cldr)), negativeProperties[0], negativeProperties[10].replace("%", "").replace("‰", ""), invertedNuDigitsMap] }; var numberPattern = function (style, cldr) { if (style !== "decimal" && style !== "percent") { throw new Error("Invalid style") } return cldr.main(["numbers", style + "Formats-numberSystem-" + numberNumberingSystem(cldr), "standard"]) }; function validateDigits(properties) { var minimumIntegerDigits = properties[2], minimumFractionDigits = properties[3], maximumFractionDigits = properties[4], minimumSignificantDigits = properties[5], maximumSignificantDigits = properties[6]; if (!isNaN(minimumSignificantDigits * maximumSignificantDigits)) { validateParameterRange(minimumSignificantDigits, "minimumSignificantDigits", 1, 21); validateParameterRange(maximumSignificantDigits, "maximumSignificantDigits", minimumSignificantDigits, 21) } else if (!isNaN(minimumSignificantDigits) || !isNaN(maximumSignificantDigits)) { throw new Error("Neither or both the minimum and maximum significant digits must be " + "present") } else { validateParameterRange(minimumIntegerDigits, "minimumIntegerDigits", 1, 21); validateParameterRange(minimumFractionDigits, "minimumFractionDigits", 0, 20); validateParameterRange(maximumFractionDigits, "maximumFractionDigits", minimumFractionDigits, 20) } } Globalize.numberFormatter = Globalize.prototype.numberFormatter = function (options) { var args, cldr, pattern, properties, returnFn; validateParameterTypePlainObject(options, "options"); options = options || {}; cldr = this.cldr; args = [options]; validateDefaultLocale(cldr); cldr.on("get", validateCldr); if (options.raw) { pattern = options.raw } else { pattern = numberPattern(options.style || "decimal", cldr) } properties = numberFormatProperties(pattern, cldr, options); cldr.off("get", validateCldr); validateDigits(properties); returnFn = numberFormatterFn(properties); runtimeBind(args, cldr, returnFn, [properties]); return returnFn }; Globalize.numberParser = Globalize.prototype.numberParser = function (options) { var args, cldr, pattern, properties, returnFn; validateParameterTypePlainObject(options, "options"); options = options || {}; cldr = this.cldr; args = [options]; validateDefaultLocale(cldr); cldr.on("get", validateCldr); if (options.raw) { pattern = options.raw } else { pattern = numberPattern(options.style || "decimal", cldr) } properties = numberParseProperties(pattern, cldr); cldr.off("get", validateCldr); returnFn = numberParserFn(properties); runtimeBind(args, cldr, returnFn, [properties]); return returnFn }; Globalize.formatNumber = Globalize.prototype.formatNumber = function (value, options) { validateParameterPresence(value, "value"); validateParameterTypeNumber(value, "value"); return this.numberFormatter(options)(value) }; Globalize.parseNumber = Globalize.prototype.parseNumber = function (value, options) { validateParameterPresence(value, "value"); validateParameterTypeString(value, "value"); return this.numberParser(options)(value) }; Globalize._createErrorUnsupportedFeature = createErrorUnsupportedFeature; Globalize._numberNumberingSystem = numberNumberingSystem; Globalize._numberPattern = numberPattern; Globalize._numberSymbol = numberSymbol; Globalize._stringPad = stringPad; Globalize._validateParameterTypeNumber = validateParameterTypeNumber; Globalize._validateParameterTypeString = validateParameterTypeString; return Globalize });